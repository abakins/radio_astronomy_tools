# Solar system object tools 

## uvplanetfit.py 
uvplanetfit functions serve as alternatives to the CASA task [uvmodelfit](https://casadocs.readthedocs.io/en/latest/api/tt/casatasks.manipulation.uvmodelfit.html) which is focused on models which are relevant to planets. Unlike uvmodelfit, however, it doesn't interface with CASA measurement sets directly, and instead requires extraction of the relevant data using ms.getdata. Examples for this process are shown below in demonstration scripts for each function. It also creates model images for tclean's startmodel parameter instead of CASA component lists. 

### uvplanetfit
In addition to generating a uniform disk model, uvplanetfit can also fit limb-darkening and ellipsoid shape models. This function can only be used for co-polarized visibilities.

Parameters which can be fit (added via fit_params as a dictionary including starting guesses)
Other values are either assumed by default or can be added via static_params

Valid fit_params include: 
- 'Io': Disk intensity (Jy * Distance^2 / Area)
- 'r': Disk radius in radians 
- 'p': Limb darkening parameter 
- 'b': Ratio of long to short axis of disk
- 'phi': Counterclockwise rotation (in degrees) of the long axis relative to the image "l" coordinate (generally the horizontal axis)

```python
# Example test 
import scipy.constants as spc 
import casatools
ms = casatools.ms()

filename='your-ms-here' 
ms.open(filename)
# Note that the specifics of data extraction will vary based on the ms structure. Here is one example
data = ms.getdata(['real', 'imaginary', 'u', 'v', 'uvdist', 'flag', 'axis_info', 'data_desc_id', 'scan_number'])
# Select only linear or circular polarizations 
corrs = data['axis_info']['corr_axis']
corrdex = [i for i in range(len(corrs)) if corrs[i][0] == corrs[i][1]]  # Accumulates only co-pols
data['real'] = data['real'][corrdex]
data['imaginary'] = data['imaginary'][corrdex]
data['flag'] = data['flag'][corrdex]
wavelength = spc.c / data['axis_info']['freq_axis']['chan_freq']
wavelength = wavelength.ravel()
mask = data['flag'] == False 
reals = data['real'][mask]
imags = data['imaginary'][mask]
u = data['u'][mask.ravel()] / wavelength 
v = data['v'][mask.ravel()] / wavelength
cvis = reals + 1j * imags

# Using Uranus-like parameters
fit_params = {'Io': 32/(np.pi * 8e-6**2), 
                'r': 8.48e-6, 
                'p': 0.1
            }
static_params = {
                'b': 1.,
                'phi': 0., 
                }
solver_kwargs = {'bounds': [(0, np.inf), (0, np.inf), (0, 1)]}
result = uvplanetfit(cvis, u, v, fit_params=fit_params, static_params=static_params, fit_reals=True, 
                        make_plots=True, savefig=None, solmode='L2', solver_kwargs=solver_kwargs, compute_sigma=True, sigma_bin=101)
```

A plot generated by this routine, fit to Sub-Millimeter Array observations of Uranus, is shown below 

![Uranus SMA fit](/solar_system/figures/uranus_sma_fit.png)


### uvplanetfit_polarized 
This procedure fits a model to cross-polarized visibilities 

Parameters which can be fit (added via fit_params as a dictionary including starting guesses)
Other values are either assumed by default or can be added via static_params

Valid fit_params include: 
- 'eps': Real part of the dielectric constant (if static, can be specified as complex)
- 'r': Disk radius in radians 
- 'b': Ratio of long to short axis of disk
- 'phi': Counterclockwise rotation (in degrees) of the long axis relative to the image "l" coordinate (generally the horizontal axis)
- 'rot_angle': Polarization angle offset (in degrees), usually a systematic term which must be corrected for. 

Note: Testing of this routine is still ongoing! 

```python
# Example test 
import scipy.constants as spc 
import casatools
ms = casatools.ms()

filename='your-ms-here' 
ms.open(filename)
# Note that the specifics of data extraction will vary based on the ms structure. Here is one example
data = ms.getdata(['real', 'imaginary', 'u', 'v', 'uvdist', 'flag', 'axis_info', 'data_desc_id', 'scan_number'])
wavelength = spc.c / data['axis_info']['freq_axis']['chan_freq']
wavelength = wavelength.ravel()
feed_type = data['axis_info']['corr_axis']
mask = data['flag'] == False
mask = np.sum(mask, axis=0, dtype='bool').ravel() # an 'or' operation along the polarization axis
reals = data['real'].squeeze()[..., mask]
imags = data['imaginary'].squeeze()[..., mask]
u = data['u'][mask]
v = data['v'][mask]
u = u / wavelength
v = v / wavelength
cvis = reals + 1j * imags

# Using Venus-like parameters
fit_params = {'eps': 5.,
                'r': 70e-6, 
                'rot_angle': 0
            }
static_params = {
                'b': 1.,
                'phi': 0., 
                }

solver_kwargs = {'bounds': [(0, np.inf), (0, np.inf), (0, np.pi)]}
result = uvplanetfit_polarized(cvis, u, v, fit_params=fit_params, static_params=static_params, fit_reals=True, 
                                make_plots=True, savefig=None, solmode='L2', solver_kwargs=solver_kwargs, 
                                compute_sigma=False, sigma_bin=101, feed_type=feed_type)
```

### uvpf_to_sm
This routine takes inputs of 

- uvpf_params: Outputs of the uvfitplanet routine
- template_fits: Template FITS image to which the model will be mapped 
- upsample: Factor by which to upsample the image (to avoid sharp corners)

and generates a FITS image which can be imported as a CASA image and used with the tclean startmodel parameter. 
It currently only works for the output of uvplanetfit (polarized output in progress)

## imagetools.py 
imagetools functions are applicable to analysis of planet images 
Many of these routines return Astropy Quantities to aid with tracking units 

### read_fits_image 
Extracts coordinate systems and quantities of interest (synthesized beams, observation dates) for input FITS images. 

### get_horizons_ephemerides
Built on the astroquery.jplhorizons module, queries JPL Horizons service for object information. 
Also computes the apparent disk dimensions from the observer's perspective assuming the body is an oblate spheroid. 